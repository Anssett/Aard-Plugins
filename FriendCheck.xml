<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Friday, April 05, 2024, 4:19 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "FriendCheck" generated by Plugin Wizard -->

<muclient>
<plugin
   name="FriendCheck"
   author="Anssett"
   id="1322d656cc4da6f69a508abb"
   language="Lua"
   purpose="Brief data on a friend that just logged on - now with wrapped captures. maybe."
   save_state="y"
   date_written="2024-04-05 16:17:22"
   requires="5.07"
   version="1.2"
   >
   <description trim="n">
    <![CDATA[
FriendCheck
------------
"fc (on|off)" to enable/disable

"fc update check" to check for updates
"fc update install" to install updates

]]>
</description>

</plugin>


<!--  Triggers  -->

<triggers>
  <trigger group="friendCheck" enabled="y" expand_variables="y" keep_evaluating="y" match="^\(Friend\): (?<name>\w+) has entered Aardwolf\.$" regexp="y" omit_from_output="y" script="startCheck" sequence="100"></trigger>
</triggers>

<!--  Plugin help  -->

<aliases>
  <alias script="OnHelp" match="fc help" enabled="y"></alias>
  <alias script="toggle" match="^fc (?<toggle>(on|off))$" enabled="y" regexp="y"></alias>
    <alias
   match="fc update check"
   enabled="y"
   script="update_check_alias"
   sequence="100"
  />
  <alias
   match="fc update install"
   enabled="y"
   script="update_install_alias"
   sequence="100"
  />
</aliases>

<script>
<![CDATA[

require "wrapped_captures"
require "aardwolf_colors"

function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end

function toggle(name,line, args)
  if args.toggle=="on" then
    EnableTriggerGroup("friendCheck",true)
    SendNoEcho("echo @CFriendCheck Plugin Enabled@w")
  elseif args.toggle=="off" then
    EnableTriggerGroup("friendCheck",false)
    SendNoEcho("echo @YFriendCheck plugin disabled@w")
  end
end


function friendCap(name)
  friendData = {
    name=name,
    level="",
    gender = "",
    race = "",
    subclass = "",
    tier = "",
    morts = "1"
  }
  command = "finger " .. name
  startLine = "^\\-+ Player : (?:\\w+) \\(.*\\) \\-+$"
  stopLine = "^\\-{60}$"
  tagsAreRegex=true
  noCommandEcho=true
  omitResponse=true
  noFollowPrompt=false
  sendViaExecute=true
    
  Capture.tagged_output(command,startLine,stopLine,tagsAreRegex,noCommandEcho,omitResponse,noFollowPrompt,processCapture,sendViaExecute,failCapture)
end

function processCapture(lines)
  new_table = {}
  for k, v in ipairs(lines) do
      stripped = strip_colours_from_styles(v)
      if stripped ~= "" then
          table.insert(new_table, stripped)
      end
  end

  for i,j in ipairs(new_table) do
      if string.find(j,"^Remort: ") ~=nil then --check for "remort" in string
        friendData.morts = countMorts(j)
      elseif string.find(j,"^Level %d+ ") ~= nil then --check for level line
        friendData.level, friendData.gender, friendData.race, friendData.subclass, friendData.tier = string.match(j, "Level (%d+) (%w+) ([%w%s-]+) (%w+) %[?%w*%]?%s?%(Tier (%d+%+?%d*)%)%.$")
      end
  end
  outFriend = friendBuild()
  SendNoEcho("echo ".. outFriend)
end

function failCapture()
    Note("Capture timed out")
end

function countMorts(remortString)
  mortcount = (select(2,string.gsub(remortString,"/","")))+1
  return mortcount
end


function startCheck(name, line, args)
  name=args.name
  friendCap(name)
end

function friendBuild()
  return "@G(Friend) @C"..  friendData.name .. " has entered Aardwolf. (".. friendData.level .. " T" .. friendData.tier .. " R"..friendData.morts.. " " .. friendData.race .. " " .. friendData.subclass .. ")@w"
end

function dump(o)
    if type(o) == 'table' then
       local s = '{ '
       for k,v in pairs(o) do
          if type(k) ~= 'number' then k = '"'..k..'"' end
          s = s .. '['..k..'] = ' .. dump(v) .. ','
       end
       return s .. '} '
    else
       return tostring(o)
    end
 end

 ----------------------- Plugin Update Code -----------------------
 -- Code taken from Durel's dinv plugin, originally via Crowley
 require("wait")
require("async")
json = require("json")

 plugin_url = "https://raw.githubusercontent.com/Anssett/Aard-Plugins/main/FriendCheck.xml"
 SetVariable("DownloadURL", plugin_url)
 plugin_protocol = "HTTPS"
 plugin_prefix = "[FriendCheck]"
 
 function update_check_alias()
     update_plugin("check")
     ColourNote("white", "", plugin_prefix .. " Checking for updated version...")
 end
 
 function update_install_alias()
     update_plugin("install")
     ColourNote("white", "", plugin_prefix .. " Checking for and installing updated version...")
 end
 
 function reload_plugin()
     local scriptPrefix = GetAlphaOption("script_prefix")
     local retval
 
     -- If the user has not already specified the script prefix for this version of mush, pick a
     -- reasonable default value
     if (scriptPrefix == "") then
         scriptPrefix = "\\\\\\"
         SetAlphaOption("script_prefix", scriptPrefix)
     end
 
     -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
     -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
     -- if it weren't installed? 
     retval = Execute(scriptPrefix.."DoAfterSpecial(0.1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
 end
 
 function update_plugin(mode)
     update_mode = mode
 
     wait.make(get_plugin_file)
 end
 
 function get_plugin_file()
     local urlThread = async.request(plugin_url, plugin_protocol)
 
     if not urlThread then
         note_error("Couldn't create async url request.")
         return
     end
 
     local timeout = 10
     local totTime = 0
     while (urlThread:alive() and totTime < timeout) do
         wait.time(0.1)
         totTime = totTime + 0.1
     end
 
     local remoteRet, pluginData, status, headers, fullStatus = urlThread:join()
 
     if not status then
         ColourNote("red", "", plugin_prefix .. " Couldn't download plugin file. No status code.")
         
         return
     end
 
     if (status ~= 200) then
         ColourNote("red", "", plugin_prefix .. " Plugin file request status code: " .. status .. ": " .. fullStatus)
         return
     end
     
     local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
     local currentVerStr  = string.format("%1.3f", currentVersion)
     local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
     local remoteVersion  = tonumber(remoteVerStr or "") or 0
 
     if remoteVersion == currentVersion then
         ColourNote("white", "", plugin_prefix .. " You are running the most recent version (v" .. currentVerStr .. ")")
     elseif (remoteVersion < currentVersion) then
         ColourNote("white", "", plugin_prefix .. " You have a newer version than is publicly available. (v" .. currentVerStr .. ")")
     elseif (update_mode == "check") then
         ColourNote("white", "", plugin_prefix .. " You are running v" .. currentVerStr .. ", but there's a newer version v" .. remoteVerStr)
     elseif (update_mode == "install") then
         ColourNote("white", "", plugin_prefix .. " Updating plugin from version " .. currentVerStr .. " to version " .. remoteVerStr) 
 
         local pluginFile = GetPluginInfo(GetPluginID(), 6)
         local file = io.open(pluginFile, "wb")
         file:write(pluginData)
         file:close()
         reload_plugin()
     else
         ColourNote("red", "", plugin_prefix .. " Invalid update mode: " .. update_mode)
     end
 end
 ----------------------- End Plugin Update Code -----------------------
 
 function OnPluginInstall()
  OnHelp()
 end

]]>



</script> 

</muclient>
