<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Tuesday, May 20, 2025, 1:15 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "GQChecker" generated by Plugin Wizard -->

<muclient>
<plugin
   name="GQChecker"
   author="Anssett"
   id="8d7a003a2a5db09d7ff0d4f7"
   language="Lua"
   purpose="Checks to see if any existing GQs are valid for you to join"
   save_state="y"
   date_written="2025-05-20 13:14:32"
   requires="5.07"
   version="1.1"
   >

</plugin>

<!--  Triggers  -->
<triggers>
  <trigger name="gqMatch" enabled="n" group="gq_checker" keep_evaluating="y" match="^\s*(?<gq_id>\d+) (?<gq_range>(Less than 25 wins|25 to 199 wins|200 Wins or more))\s+(?<gq_min_lev>\d+)\s+(?<gq_max_lev>\d+) (?<gq_status>(Active|Preparing|Extended))\s+(?<gq_timer>\d+)\s+(?<gq_players>\d+)\s*(?:\*\*\*)?$" regexp="y" script="processGQList" sequence="100"></trigger>
<!--  <trigger name="selfGQWins" enabled="n" group="gq_checker" keep_evaluating="y" match="^Quests Complete : \[\s*\d+\]\s+Quests Failed: \[\s*\d+\]\s+Gquests Won: \[\s*(?<gq_won>\d+)\]$" regexp="y" script="setGQWins" sequence="100"></trigger> -->
  <trigger name="gqMatchEnd" enabled="y" group="gq_checker" keep_evaluating="y" match="{/gqcapture}" regexp="n" script="finishGQCapture" omit_from_output="y" sequence="100"></trigger>
  <trigger name="levelMatch" group="levelChecks" enabled="n" keep_evaluating="y" match="^You raise a level! You are now level (?<level>\d+)\.$" regexp="y" script="checkGQs" sequence="100"></trigger>
  <trigger name="afkMatch" group="afkChecks" enabled="n" keep_evaluating="y" match="^Returning to game\.\.\.\.$" regexp="y" script="checkGQs" sequence="100"></trigger>
  <trigger name="afkMatch2" group="afkChecks" enabled="n" keep_evaluating="y" match="^AFK mode removed\. There are no tells waiting for you\.$" regexp="y" script="checkGQs" sequence="100"></trigger>
  <trigger name="dcMatch" group="dcChecks" enabled="n" keep_evaluating="y" match="^\#+ Reconnecting to Game \#+$" regexp="y" script="checkGQs" sequence="100"></trigger>
</triggers>

<aliases>
  <alias match="^gqcheck$" enabled="y" regexp="y" ignore_case="y" script="checkGQs" sequence="99"></alias>
  <alias match="^gqcheck help$" enabled="y" regexp="y" ignore_case="y" script="onHelp" sequence="99"></alias>
  <alias name="configMatch" match="^gqcheck config(?:\s?(?<opt>\w+))?$" enabled="y" regexp="y" ignore_case="y" script="gqcheckMain" sequence="99"></alias>
  <alias name="channelMatch" match="^gqcheck channel(?:\s?(?<opt>.+))?$" enabled="y" regexp="y" ignore_case="y" script="gqcheckMain" sequence="99"></alias>
  <alias match="gqjoin" enabled="y" regexp="n" ignore_case="y" script="joinGQs"></alias>
  <alias match="gqcheck update check" enabled="y" script="update_check_alias" sequence="99"/>
  <alias match="gqcheck update install" enabled="y" script="update_install_alias" sequence="99"/>
</aliases>

<script>
<![CDATA[
require "gmcphelper"
require "wrapped_captures"
require "tprint"
require "aardwolf_colors"

local myWins = tonumber(0)
local gqString = ""
local debug = false
local priColor = "@Y"
local secColor = "@M"
local terColor = "@w"
local tagPrefix = secColor .. "[" .. priColor .. "GQChecker" .. secColor .. "]" .. terColor .. " "
local chanPrefix = ""
local chanOn

function gqcheckMain(name,line,wildcards)
  local opt = wildcards.opt

  if name=="configMatch" and opt=="" then
    gqReportConfig()
  elseif opt == "level" then --toggle check on level 
    toggleLevelTrigger()
  elseif opt == "afk" then --toggle check on return from afk
    toggleAFKTrigger()
  elseif opt=="dc" then --toggle check on reconnect
    toggleDCTrigger()
  elseif name=="channelMatch" then
    setChannel(opt)
  else
    gqReportConfig()
  end
end

function setChannel(chanStr)
  if chanStr == "on" then
    chanOn = true
    colorsToAnsiNote(tagPrefix .. priColor .. "Channel broadcast turned " .. secColor .. "on".. priColor .. "." .. terColor)
  elseif chanStr == "off" then
    chanOn = false
    colorsToAnsiNote(tagPrefix .. priColor .. "Channel broadcast turned " .. secColor .. "off".. priColor .. "." .. terColor)
  elseif chanStr == "" then
    --do nothing bc you asked for nothing
  else
    --you must want to set the command
    chanPrefix = chanStr
        colorsToAnsiNote(tagPrefix .. priColor .. "Channel prefix set to " .. secColor .. chanPrefix .. priColor .. "." .. terColor)
  end
end

function gqReportConfig()
  if GetTriggerInfo("dcMatch",8) then dcStatus = "on" else dcStatus = "off" end
  if GetTriggerInfo("afkMatch",8) then afkStatus = "on" else afkStatus = "off" end
  if GetTriggerInfo("levelMatch",8) then levelStatus = "on" else levelStatus = "off" end
  if chanOn then chanStatus = "on" else chanStatus = "off" end
  colorsToAnsiNote(terColor .. "------- " .. secColor .. "[" .. priColor .. "GQ Checker Config" .. secColor .. "]" .. terColor .. " -------")
  colorsToAnsiNote(priColor .. " Level up GQ Check:   " .. terColor .. levelStatus)
  colorsToAnsiNote(priColor .. " Disconnect GQ Check: " .. terColor .. dcStatus)
  colorsToAnsiNote(priColor .. " AFK GQ Check:        " .. terColor .. afkStatus)
  colorsToAnsiNote(priColor .. " Channel Broadcast:   " .. terColor .. chanStatus)
  colorsToAnsiNote(priColor .. " Channel prefix set to ")
  colorsToAnsiNote(secColor .. "          " .. chanPrefix)
  Note()
end

function toggleDCTrigger()
  local onoffString = tagPrefix .. terColor .. "Disconnect check trigger is " .. secColor
  EnableTriggerGroup("dcChecks",not GetTriggerInfo("dcMatch",8))
  if GetTriggerInfo("dcMatch",8) then onoffString = onoffString .. "on" else onoffString = onoffString .. "off" end
  onoffString = onoffString .. priColor .. "." .. terColor
  colorsToAnsiNote(onoffString)
end

function toggleAFKTrigger()
  local onoffString = tagPrefix .. terColor .. "AFK check trigger is " ..secColor
  EnableTriggerGroup("afkChecks",not GetTriggerInfo("afkMatch",8))
  if GetTriggerInfo("afkMatch",8) then onoffString = onoffString .. "on" else onoffString = onoffString .. "off" end
  onoffString = onoffString .. priColor .. "." .. terColor
  colorsToAnsiNote(onoffString)
end

function toggleLevelTrigger()
  local onoffString = tagPrefix .. terColor .. "Level check trigger is " .. secColor
  EnableTriggerGroup("levelChecks",not GetTriggerInfo("levelMatch",8))
  if GetTriggerInfo("levelMatch",8) then onoffString = onoffString .. "on" else onoffString = onoffString .. "off" end
  onoffString = onoffString .. priColor .. "." .. terColor
  colorsToAnsiNote(onoffString)
end


function processGQList(name,line,wildcards)
  local myLevel = tonumber(gmcp("char.base.level"))
  local maxLev = tonumber(wildcards.gq_max_lev)
  local minLev = tonumber(wildcards.gq_min_lev)
  local gqRange = wildcards.gq_range

  if (myWins >=0) and (myWins <25) then gqWins = 0
  elseif (myWins >=25) and (myWins <200) then gqWins = 1
  elseif myWins >=200 then gqWins = 2
  end

  if (gqRange == "Less than 25 wins") then gqWinRange = 0
  elseif (gqRange == "25 to 199 wins") then gqWinRange = 1
  elseif (gqRange =="200 Wins or more") then gqWinRange = 2
  else Note("your gq range is broken...")
  end
  
  if debug then Note(myLevel .. " " .. maxLev .. " " .. minLev .. " " .. gqRange) end
  
  if (myLevel>=minLev) and (myLevel<=maxLev) then
    if debug then Note("I'm in level range!") end
    if(gqWins == gqWinRange) then
      colorsToAnsiNote(tagPrefix .. priColor .. " You can join gq# " .. wildcards.gq_id .. ".")
      if chanOn then Execute(chanPrefix .. tagPrefix .. priColor .. " You can join gq# " .. wildcards.gq_id .. ".") end
      gqString = gqString .. "gq join " .. wildcards.gq_id .. ";"
    else
      if debug then Note("not in the right wins bracket :(") end
    end
  else
  if debug then Note("I'm out of level range!") end
  end

  if gqString ~="" then
    SetClipboard(gqString)
    colorsToAnsiNote(tagPrefix .. terColor .. gqString .. priColor .. " copied to the clipboard." .. terColor)
    gqString = ""
  end
end

function processCaptureMyGQ(lines)
	local target = gmcp("char.base.name")
	local matched = ""
	pattern="%s*%d+%) "..target.."+%s*%a+%s*%d+%s*%d+%s*%d+%s*%d+%s*(%d+)"
	for _,v in ipairs(lines) do
		local stripped = strip_colours_from_styles(v)
		matched = string.match(stripped,pattern)
		if (matched~=nil) then 
			myWins = tonumber(matched)
			if debug then Note(myWins) end
			break
		end
	end
end

function captureTimeout()
  colorsToAnsiNote(tagPrefix .. terColor .. "Capture timed out")
  EnableTriggerGroup("gq_checker",false)
end

function finishGQCapture()
  EnableTriggerGroup("gq_checker",false)
  if (gqString ~="") then
    Note(gqString)
  end
end

function setGQWins(name,line,wildcards)
  myWins = tonumber(wildcards.gq_won)
end

function checkGQs()
  initGQs()
  EnableTriggerGroup("gq_checker",true)
  myLevel = tonumber(gmcp("char.base.level"))
  --Execute("whois")
  local command = "echo {gqcheck};myrank 5;echo {/gqcheck}"
  local startTag = "{gqcheck}"
  local endTag = "{/gqcheck}"
  local tagsAreRegex=false
  local noCommandEcho=true
  local omitResponse=true
  local noFollowPrompt=false
  local sendViaExecute=true

  Capture.tagged_output(command,startTag,endTag,tagsAreRegex,noCommandEcho,omitResponse,noFollowPrompt,processCaptureMyGQ,sendViaExecute,captureTimeout)
  SendNoEcho("gq l")
  SendNoEcho("echo {/gqcapture}")
end

function joinGQs()

end

function initGQs()
  gqString = ""
  gqWins = tonumber(0)
  maxLev = 0
  minLev = 0
  gqRange = ""

end

--general utility things

function onHelp()
  colorsToAnsiNote(terColor .. "-------------------- " .. secColor .. "[" .. priColor .. "GQ Checker" .. secColor .. "]" .. terColor .. " --------------------")
  colorsToAnsiNote(priColor .. "gqcheck"..terColor..":        Base command. Can use this by itself to manually check GQs.")
  colorsToAnsiNote(terColor .. "                Can also call this from your own triggers and timers and such")
  colorsToAnsiNote(terColor .. "                by sending to Execute.")
  colorsToAnsiNote(priColor .. "gqcheck config" .. terColor .. ": Displays current configuration settings.")
  colorsToAnsiNote(priColor .. "gqcheck config" .. secColor .. " (level|afk|dc)" .. terColor .. ": ")
  colorsToAnsiNote(terColor .. "                Toggle on/off the built-in GQ checks on leveling up, returning")
  colorsToAnsiNote(terColor .. "                from AFK, and reconnecting after a DC.")
  Note()
  colorsToAnsiNote(priColor .. "gqcheck channel" .. secColor .. " (on|off)" .. terColor .. ": ")
  colorsToAnsiNote(terColor .. "                Toggle broadcasting on/off to a specified channel.")
  colorsToAnsiNote(terColor .. "                Will probably break if you don't configure the channel also.")
  colorsToAnsiNote(priColor .. "gqcheck channel" .. secColor .. " <command>" .. terColor .. ": ")
  colorsToAnsiNote(terColor .. "                Sets the channel prefix that you want to output to. For example,")
  colorsToAnsiNote(terColor .. "                gqcheck channel spouse will send notifications to spouse as well as note.")
  Note()
  colorsToAnsiNote(priColor .. "gqcheck help" .. terColor .. ":   This helpfile.")
  Note()
  colorsToAnsiNote(priColor .. "gqcheck update check" .. terColor .. ":")
  colorsToAnsiNote(terColor .. "                Check for updates.")
  colorsToAnsiNote(priColor .. "gqcheck update install" .. terColor .. ":")
  colorsToAnsiNote(terColor .. "                Install any available updates.")
  Note()
end

function colorsToAnsiNote(data)
  return AnsiNote(ColoursToANSI(data))
end

function OnPluginSaveState()
	SetVariable("GQAfk",tostring(GetTriggerInfo("afkMatch",8)))
  SetVariable("GQLevel",tostring(GetTriggerInfo("levelMatch",8)))
  SetVariable("GQDC",tostring(GetTriggerInfo("dcMatch",8)))
  SetVariable("GQChanOn",tostring(chanOn))
  SetVariable("GQChanPrefix", chanPrefix)
end

function OnPluginInstall(msg, id, name, text)
  EnableTriggerGroup("dcChecks", toBoolean(GetVariable("GQDC")))
  EnableTriggerGroup("afkChecks", toBoolean(GetVariable("GQAfk")))
  EnableTriggerGroup("levelChecks", toBoolean(GetVariable("GQLevel")))
  chanOn = toBoolean(GetVariable("GQChanOn")) or false
  chanPrefix = GetVariable("GQChanPrefix") or ""
end

function toBoolean(input)
  if(input == nil) then return false end
  return string.lower(input) == "true"
end

 ----------------------- Plugin Update Code -----------------------
 -- Code taken from Durel's dinv plugin, originally via Crowley
 require("wait")
require("async")
json = require("json")

 plugin_url = "https://raw.githubusercontent.com/Anssett/Aard-Plugins/refs/heads/main/GQ_Checker/GQChecker.xml"
 SetVariable("DownloadURL", plugin_url)
 plugin_protocol = "HTTPS"
 plugin_prefix = "[GQ_Checker]"
 
 function update_check_alias()
     update_plugin("check")
     ColourNote("white", "", plugin_prefix .. " Checking for updated version...")
 end
 
 function update_install_alias()
     update_plugin("install")
     ColourNote("white", "", plugin_prefix .. " Checking for and installing updated version...")
 end
 
 function reload_plugin()
     local scriptPrefix = GetAlphaOption("script_prefix")
     local retval
 
     -- If the user has not already specified the script prefix for this version of mush, pick a
     -- reasonable default value
     if (scriptPrefix == "") then
         scriptPrefix = "\\\\\\"
         SetAlphaOption("script_prefix", scriptPrefix)
     end
 
     -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
     -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
     -- if it weren't installed? 
     retval = Execute(scriptPrefix.."DoAfterSpecial(0.1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
 end
 
 function update_plugin(mode)
     update_mode = mode
 
     wait.make(get_plugin_file)
 end
 
 function get_plugin_file()
     local urlThread = async.request(plugin_url, plugin_protocol)
 
     if not urlThread then
         note_error("Couldn't create async url request.")
         return
     end
 
     local timeout = 10
     local totTime = 0
     while (urlThread:alive() and totTime < timeout) do
         wait.time(0.1)
         totTime = totTime + 0.1
     end
 
     local remoteRet, pluginData, status, headers, fullStatus = urlThread:join()
 
     if not status then
         ColourNote("red", "", plugin_prefix .. " Couldn't download plugin file. No status code.")
         
         return
     end
 
     if (status ~= 200) then
         ColourNote("red", "", plugin_prefix .. " Plugin file request status code: " .. status .. ": " .. fullStatus)
         return
     end
     
     local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
     local currentVerStr  = string.format("%1.3f", currentVersion)
     local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
     local remoteVersion  = tonumber(remoteVerStr or "") or 0
 
     if remoteVersion == currentVersion then
         ColourNote("white", "", plugin_prefix .. " You are running the most recent version (v" .. currentVerStr .. ")")
     elseif (remoteVersion < currentVersion) then
         ColourNote("white", "", plugin_prefix .. " You have a newer version than is publicly available. (v" .. currentVerStr .. ")")
     elseif (update_mode == "check") then
         ColourNote("white", "", plugin_prefix .. " You are running v" .. currentVerStr .. ", but there's a newer version v" .. remoteVerStr)
     elseif (update_mode == "install") then
         ColourNote("white", "", plugin_prefix .. " Updating plugin from version " .. currentVerStr .. " to version " .. remoteVerStr) 
 
         local pluginFile = GetPluginInfo(GetPluginID(), 6)
         local file = io.open(pluginFile, "wb")
         file:write(pluginData)
         file:close()
         reload_plugin()
     else
         ColourNote("red", "", plugin_prefix .. " Invalid update mode: " .. update_mode)
     end
 end
 ----------------------- End Plugin Update Code -----------------------

]]>
</script>
</muclient>
