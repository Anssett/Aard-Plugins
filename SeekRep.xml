<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, June 06, 2024, 8:25 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "SeekRep" generated by Plugin Wizard -->

<!--
comments go here
-->

<muclient>
<plugin
   name="SeekRep"
   author="Anssett"
   id="c9e9e568ec2b3bafe4dc76fa"
   language="Lua"
   purpose="To do things with Seek output."
   save_state="y"
   date_written="2024-06-06 20:24:22"
   requires="5.07"
   version="1.4"
   >
<description trim="y">
<![CDATA[
SeekRep
-------
Seek clanskill output reporter.

ON FIRST SETUP, START WITH:
    seekrep config help

seekrep <target> [top|bot] [quantity]
    <target>    Required. Single keyword of target. Ordinal targets are ok (1.lasher, 2.lasher, etc.)
                multiple words or quotes are not.
    [top|bot]   Optional. Sort order. defaults to "bot". "bot" sorts ascending, "top" sorts descending. 
    [quantity]  Optional. Restricts quantity of results.

Examples:
    seekrep lasher top 3
      Performs "seek" on lasher, then prints his highest 3 resistances.
    
    seekrep lasher 5
      Performs "seek" on lasher, then prints his lowest 5 resistances.

Updating:
    seekrep update check:   Checks if there's an update to the plugin.
    seekrep update install: Installs any available updates to this plugin.

]]>
</description>

</plugin>

<triggers></triggers>

<aliases>
  <alias match="^seekrep\s(?<name>((\d*\.)?\w+))\s?(?<dir>(top|bot))?\s?(?<qty>\d+)?" script="startSeek" regexp="y" enabled="y" group="seekrep" send_to="12" sequence="100" ></alias>
  <alias script="OnHelp" match="seekrep help" enabled="y"></alias>
  <alias match="seekrep update check" enabled="y" script="update_check_alias" sequence="99"/>
  <alias match="seekrep update install" enabled="y" script="update_install_alias" sequence="99"/>

  <alias match="^seekrep config(\s((?<command>(echo|channel|rvcolor|rncolor|sepcolor)) (?<value>.+)))?$" enabled="y" regexp="y" script="config_handler" sequence="99"></alias>
  <alias match="^seekrep config (?<command>reset|help)$" enabled="y" regexp="y" script="config_handler" sequence="99"></alias>
</aliases>

<script>
<![CDATA[
require 'wrapped_captures'
require 'aardwolf_colors'
require 'tprint'

function seekFail()
  Note("something broke. Or seek failed and you need to try again.")
end

function initTarget()
targetArray = {
  shortn = "",
  baselev = 0,
  identical = 0,
  timeskilled = 0,
  align = "",
  immunities = "",
  notes = "",
  resists={
    {resName="Air", resval=0},
    {resName="Acid", resval=0},
    {resName="Bash", resval=0},
    {resName="Cold", resval=0},
    {resName="Disease", resval=0},
    {resName="Earth", resval=0},
    {resName="Electric", resval=0},
    {resName="Energy", resval=0},
    {resName="Fire", resval=0},
    {resName="Holy", resval=0},
    {resName="Light", resval=0},
    {resName="Magic", resval=0},
    {resName="Mental", resval=0},
    {resName="Negative", resval=0},
    {resName="Pierce", resval=0},
    {resName="Poison", resval=0},
    {resName="Shadow", resval=0},
    {resName="Slash", resval=0},
    {resName="Sonic", resval=0},
    {resName="Water", resval=0}
    }
}
end

function trim(s)
  return(string.gsub(s, "^%s*(.-)%s*$", "%1"))
end

function resSplit(instring)
  split1 = trim(string.sub(instring,0,31))
  split2 = trim(string.sub(instring,31,58))
  if(split1 ~= "") then
    local tbl = resSubSplit(split1)
    for i,j in ipairs(targetArray.resists) do
        if j.resName == tbl[1] then j.resval = tonumber(tbl[2]) end
    end
  end
  if (split2 ~= "") then
    local tbl=resSubSplit(split2)
    for i,j in ipairs(targetArray.resists) do
        if j.resName == tbl[1] then j.resval = tonumber(tbl[2]) end
    end
  end
end

function resSubSplit(instring)
  local splitTable = {}
  for str in string.gmatch(instring,"([^:]+)") do
    local tmpstr = string.gsub(str,"%%","")
    table.insert(splitTable,trim(tmpstr))
  end
  return splitTable
end

function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end

function startSeek(name,line, args)
  target = args.name
  dir = args.dir or "nil"
  qty = tonumber(args.qty) or -1
  initTarget()

  local command = "seek " .. target
  local startTag = "^\\-+$"
  local endTag = "^\\-+$"
  local tagsAreRegex=true
  local noCommandEcho=false
  local omitResponse=true
  local noFollowPrompt=false
  local sendViaExecute=true

  Capture.tagged_output(command,startTag,endTag,tagsAreRegex,noCommandEcho,omitResponse,noFollowPrompt,processCapture,sendViaExecute,seekFail)
end

function processCapture(lines)
  new_table = {}

  --remove color data etc
  for k, v in ipairs(lines) do
      stripped = strip_colours_from_styles(v)
      if (stripped ~= "" and 
          stripped ~="------------------------- [ Resistances ] ----------------------") then
          table.insert(new_table, trim(stripped))
      end
  end

  --process de-colored data
  for i,j in ipairs(new_table) do
      --Note("i: " .. i .. " j: " .. j)
      if string.find(j,"Mob Short Name") ~=nil then
        targetArray.shortn = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Mob Base Level") ~= nil then
        targetArray.baselev = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Identical Mobs") ~= nil then
        targetArray.identical = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Times Killed") ~= nil then
        targetArray.timeskilled = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Alignment") ~= nil then
        targetArray.align = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Immunities") ~= nil then
        targetArray.immunities = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Note") ~= nil then
        targetArray.notes = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"%a+%s+:%s+[-%.%d]+") ~= nil then
        resSplit(j)
      end
  end

  if qty>0 then
    local outText = tableString(getTableX(qty,dir))
    if getEcho() then
      colorsToAnsiNote(outText)
    end
    SendNoEcho(getChannel() .. " "..outText)
  else
    tprint(targetArray)
    --nobody's going to use this, right?
  end
  
end

function colorsToAnsiNote(data)
  return AnsiNote(ColoursToANSI(data))
end

function tblLT(a,b)
  return a.resval<b.resval
end

function tblGT(a,b)
  return b.resval<a.resval
end

function getTableX(amount,direction)
  local outTable = {}
  if(direction == "top") then --sort largest -> smallest
    table.sort(targetArray.resists,tblGT)  
  else -- sort smallest -> largest. default for now, probably most common.
    table.sort(targetArray.resists,tblLT)
  end
  if amount<1 then amount=#targetArray.resists end
    for x=1,amount do
      if targetArray.resists[x].resval ~= 0 then
        table.insert(outTable,targetArray.resists[x])
      end
    end
  return outTable
end

function tableString(intab)
  local buildString = ""
  local sepColor = getSepColor()
  local resNameColor = getResNameColor()
  local resValColor = getResValColor()

  for x=1,#intab do
    buildString = buildString .. resNameColor.. intab[x].resName..": "..resValColor ..intab[x].resval .. "%" .. sepColor .. " | @w"
  end

  buildString = buildString .. resNameColor .. "Target: " .. targetArray.shortn

  return buildString
end

function config_handler(name, line, args)
    arg = args.command
   if arg=="" then
     Note("SeekRep Configs:")
     Note("Echo:                " .. tostring(getEcho()))
     Note("Channel:             " .. getChannel())
     Note("Resist Value Color:  ".. getResValColor())
     Note("Resist Name Color:   " .. getResNameColor())
     Note("Separator Color:     "..getSepColor())
   elseif arg == "echo" then
      Note("Toggled Echo to "..args.value)
      setEcho(args.value)
   elseif arg == "channel" then
      Note("Set reporting channel to " .. args.value)
      setChannel(args.value)
   elseif arg == "rvcolor" then
      Note("Set resist value color to ".. args.value)
      setResValColor(args.value)
   elseif arg == "rncolor" then
      Note("Set resist name color to ".. args.value)
      setResNameColor(args.value)
   elseif arg == "sepcolor" then
      Note("Set separator color to " .. args.value)
      setSepColor(args.value)
   elseif arg == "help" then
      configHelp()
   elseif arg== "reset" then
     Note("Resetting config to defaults.")
     --reset things
     SaveState()
   end
 end

 function setEcho(value)
  SetVariable("outEcho",value)
  SaveState()
 end
 
 function getEcho()
  local echo = GetVariable("outEcho")
  return echo
 end

 function setChannel(value)
  SetVariable("outChannel",value)
  SaveState()
 end

 function getChannel()
  local chan = GetVariable("outChannel")
  return chan
 end
 
 function setResValColor(value)
  SetVariable("resValColor",value)
  SaveState()
 end

 function getResValColor()
  local rvColor = GetVariable("resValColor")
  return rvColor
 end

 function setResNameColor(value)
  SetVariable("resNameColor",value)
  SaveState()
 end
 
 function getResNameColor()
  local rnColor = GetVariable("resNameColor")
  return rnColor
 end
 
 function setSepColor(value)
  SetVariable("sepColor",value)
  SaveState()
 end
 
 function getSepColor()
  local sepColor = GetVariable("sepColor")
  return sepColor
 end

function configHelp()
  Note("Config options:")
  Note("seekrep config [echo|channel|rvcolor|rncolor|sepcolor|reset|help] <value>")
  Note("  echo:     [true|false] - enables or disables local echo of seek results")
  Note("  channel:  [string] - set the game channel that seek reports to")
  Note("  rvcolor:  [string] - set the color code for resist values. Use @ prefixed colors. Supports xterm or mud colors.")
  Note("  rncolor:  [string] - set the color code for resist names. Use @ prefixed colors. Supports xterm or mud colors.")
  Note("  sepcolor: [string] - set the color code for the separator characters. Supports xterm or mud colors.")
  Note("  reset:    resets config values to defaults.")
  Note("  help:     This data.")

end

function isEmpty(testme)
  return testme == nil or testme==""
end

function resetVars()
  setResValColor("@x184")
  setResNameColor("@W")
  setSepColor("@M")
  setChannel("gtell")
  setEcho("true")
end

function initVars()
  if isEmpty(getResValColor()) then setResValColor("@x184") end
  if isEmpty(getResNameColor()) then setResNameColor("@W") end
  if isEmpty(getSepColor()) then setSepColor("@M") end
  if isEmpty(getChannel()) then setChannel("gtell") end
  if isEmpty(getEcho()) then setEcho("true") end
end

function OnPluginInstall()
  OnHelp()
  initVars()
 end

   --[[
  again disabling tracker code for the moment...
 function getTracker()
  local trk = GetVariable("trackerString") or false
  return trk
end

function setTracker(value)
  SetVariable("trackerString",value)
  SaveState()
end
]]



 ----------------------- Plugin Update Code -----------------------
 -- Code taken from Durel's dinv plugin, originally via Crowley
 require("wait")
require("async")
json = require("json")

 plugin_url = "https://raw.githubusercontent.com/Anssett/Aard-Plugins/main/SeekRep.xml"
 SetVariable("DownloadURL", plugin_url)
 plugin_protocol = "HTTPS"
 plugin_prefix = "[SeekRep]"
 
 function update_check_alias()
     update_plugin("check")
     ColourNote("white", "", plugin_prefix .. " Checking for updated version...")
 end
 
 function update_install_alias()
     update_plugin("install")
     ColourNote("white", "", plugin_prefix .. " Checking for and installing updated version...")
 end
 
 function reload_plugin()
     local scriptPrefix = GetAlphaOption("script_prefix")
     local retval
 
     -- If the user has not already specified the script prefix for this version of mush, pick a
     -- reasonable default value
     if (scriptPrefix == "") then
         scriptPrefix = "\\\\\\"
         SetAlphaOption("script_prefix", scriptPrefix)
     end
 
     -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
     -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
     -- if it weren't installed? 
     retval = Execute(scriptPrefix.."DoAfterSpecial(0.1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
 end
 
 function update_plugin(mode)
     update_mode = mode
 
     wait.make(get_plugin_file)
 end
 
 function get_plugin_file()
     local urlThread = async.request(plugin_url, plugin_protocol)
 
     if not urlThread then
         note_error("Couldn't create async url request.")
         return
     end
 
     local timeout = 10
     local totTime = 0
     while (urlThread:alive() and totTime < timeout) do
         wait.time(0.1)
         totTime = totTime + 0.1
     end
 
     local remoteRet, pluginData, status, headers, fullStatus = urlThread:join()
 
     if not status then
         ColourNote("red", "", plugin_prefix .. " Couldn't download plugin file. No status code.")
         
         return
     end
 
     if (status ~= 200) then
         ColourNote("red", "", plugin_prefix .. " Plugin file request status code: " .. status .. ": " .. fullStatus)
         return
     end
     
     local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
     local currentVerStr  = string.format("%1.3f", currentVersion)
     local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
     local remoteVersion  = tonumber(remoteVerStr or "") or 0
 
     if remoteVersion == currentVersion then
         ColourNote("white", "", plugin_prefix .. " You are running the most recent version (v" .. currentVerStr .. ")")
     elseif (remoteVersion < currentVersion) then
         ColourNote("white", "", plugin_prefix .. " You have a newer version than is publicly available. (v" .. currentVerStr .. ")")
     elseif (update_mode == "check") then
         ColourNote("white", "", plugin_prefix .. " You are running v" .. currentVerStr .. ", but there's a newer version v" .. remoteVerStr)
     elseif (update_mode == "install") then
         ColourNote("white", "", plugin_prefix .. " Updating plugin from version " .. currentVerStr .. " to version " .. remoteVerStr) 
 
         local pluginFile = GetPluginInfo(GetPluginID(), 6)
         local file = io.open(pluginFile, "wb")
         file:write(pluginData)
         file:close()
         reload_plugin()
     else
         ColourNote("red", "", plugin_prefix .. " Invalid update mode: " .. update_mode)
     end
 end
 ----------------------- End Plugin Update Code -----------------------

]]>
</script> 

</muclient>
