<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, June 06, 2024, 8:25 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "SeekRep" generated by Plugin Wizard -->

<!--
comments go here
-->

<muclient>
<plugin
   name="SeekRep"
   author="Anssett"
   id="c9e9e568ec2b3bafe4dc76fa"
   language="Lua"
   purpose="To do things with Seek output."
   save_state="y"
   date_written="2024-06-06 20:24:22"
   requires="5.07"
   version="1.1"
   >
<description trim="y">
<![CDATA[
SeekRep
-------
Seek output reporter. Basic functionality for now, just sends to "note". Someday that will change.

seekrep <target> [top|bot] [quantity] - performs seek on <target> and reports it. not pretty.
    <target>:   required. single keyword of target (don't get cute and use 2 words. quotes are untested)
    [top|bot]:  optional, sort order. defaults to "bot". "bot" sorts ascending, "top" sorts descending. 
                mostly used in conjunction with quantity.
    [quantity]: optional, restricts quantity of results.

Examples:
    seekrep lasher
      performs "seek" on lasher, and dumps the entirety of the results to note. in an ugly format.
              fairly useless at the moment.
    
    seekrep lasher top 3
      performs "seek" on lasher, then prints his highest 3 resistances
    
    seekrep lasher 5
        performs "seek" on lasher, then prints his lowest 5 resistances. assuming I got the defaults correct.
            Better to specify the order you want your seeking results in to be safe.

Updating:
    seekrep update check: checks if there's an update to the plugin
    seekrep update install: installs any available updates to this plugin.

]]>
</description>

</plugin>


<!--  Triggers  -->

<triggers>
  <trigger enabled="y" group="seekrep" keep_evaluating="y" script="seekFail" match="^Your fail to seek your target correctly\.$" regexp="y" send_to="12" sequence="100"></trigger>
</triggers>

<!--  Aliases  -->

<aliases>
<!--  <alias match="^seekrep (?<name>(.*))" script="startSeek" regexp="y" enabled="y" group="seekrep" send_to="12" sequence="100" ></alias> -->
  <alias match="^seekrep\s(?<name>(\w+))\s?(?<dir>(top|bot))?\s?(?<qty>\d+)?" script="startSeek" regexp="y" enabled="y" group="seekrep" send_to="12" sequence="100" ></alias>
  <alias script="OnHelp" match="seekrep help" enabled="y"></alias>
  <alias
  match="seekrep update check"
  enabled="y"
  script="update_check_alias"
  sequence="99"
 />
 <alias
  match="seekrep update install"
  enabled="y"
  script="update_install_alias"
  sequence="99"
 />
</aliases>

<script>
<![CDATA[

require "wrapped_captures"
require "aardwolf_colors"
require "tprint"

function disableSeek()
--  EnableTriggerGroup("seekrep",false)
end

function seekFail()
--  disableSeek()
  Note("something broke. Or seek failed and you need to try again.")
end

function initTarget()
targetArray = {
  shortn = "",
  baselev = 0,
  identical = 0,
  timeskilled = 0,
  align = "",
  immunities = "",
  notes = "",
  resists={
    {resName="Air", resval=0},
    {resName="Acid", resval=0},
    {resName="Bash", resval=0},
    {resName="Cold", resval=0},
    {resName="Disease", resval=0},
    {resName="Earth", resval=0},
    {resName="Electric", resval=0},
    {resName="Energy", resval=0},
    {resName="Fire", resval=0},
    {resName="Holy", resval=0},
    {resName="Light", resval=0},
    {resName="Magic", resval=0},
    {resName="Mental", resval=0},
    {resName="Negative", resval=0},
    {resName="Pierce", resval=0},
    {resName="Poison", resval=0},
    {resName="Shadow", resval=0},
    {resName="Slash", resval=0},
    {resName="Sonic", resval=0},
    {resName="Water", resval=0}
    }
}
end

function trim(s)
  return(string.gsub(s, "^%s*(.-)%s*$", "%1"))
end

function resSplit(instring)
  split1 = trim(string.sub(instring,0,31))
  split2 = trim(string.sub(instring,31,58))
  if(split1 ~= "") then
    local tbl = resSubSplit(split1)
    for i,j in ipairs(targetArray.resists) do
        if j.resName == tbl[1] then j.resval = tonumber(tbl[2]) end
    end
  end
  if (split2 ~= "") then
    local tbl=resSubSplit(split2)
    for i,j in ipairs(targetArray.resists) do
        if j.resName == tbl[1] then j.resval = tonumber(tbl[2]) end
    end
  end
end

function resSubSplit(instring)
  local splitTable = {}
  for str in string.gmatch(instring,"([^:]+)") do
    local tmpstr = string.gsub(str,"%%","")
    table.insert(splitTable,trim(tmpstr))
  end
  return splitTable
end

function table_to_string(tbl)
  local result = "{"
  for k, v in pairs(tbl) do
      -- Check the key type (ignore any numerical keys - assume its an array)
      if type(k) == "string" then
          result = result.."[\""..k.."\"]".."="
      end

      -- Check the value type
      if type(v) == "table" then
          result = result..table_to_string(v)
      elseif type(v) == "boolean" then
          result = result..tostring(v)
      else
          result = result.."\""..v.."\""
      end
      result = result..","
  end
  -- Remove leading commas from the result
  if result ~= "" then
      result = result:sub(1, result:len()-1)
  end
  return result.."}"
end

function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end

function startSeek(name,line, args)
  target = args.name
  dir = args.dir or "nil"
  qty = tonumber(args.qty) or -1
  initTarget()

  local command = "seek " .. target
  --startTag = "^Your research into .* reveals the following \\.\\.\\.\\. $"
  local startTag = "^\\-+$"
  --endTag = "^You are charged \\d+ gold clan skill fee\\.$"
  local endTag = "^\\-+$"
  local tagsAreRegex=true
  local noCommandEcho=false
  local omitResponse=true
  local noFollowPrompt=false
  local sendViaExecute=true

  Capture.tagged_output(command,startTag,endTag,tagsAreRegex,noCommandEcho,omitResponse,noFollowPrompt,processCapture,sendViaExecute,seekFail)
end

function processCapture(lines)
  new_table = {}

  --remove color data etc
  for k, v in ipairs(lines) do
      stripped = strip_colours_from_styles(v)
      if (stripped ~= "" and 
          stripped ~="------------------------- [ Resistances ] ----------------------") then
          table.insert(new_table, trim(stripped))
      end
  end

  --process de-colored data
  for i,j in ipairs(new_table) do
      --Note("i: " .. i .. " j: " .. j)
      if string.find(j,"Mob Short Name") ~=nil then
        targetArray.shortn = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Mob Base Level") ~= nil then
        targetArray.baselev = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Identical Mobs") ~= nil then
        targetArray.identical = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Times Killed") ~= nil then
        targetArray.timeskilled = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Alignment") ~= nil then
        targetArray.align = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Immunities") ~= nil then
        targetArray.immunities = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Note") ~= nil then
        targetArray.notes = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"%a+%s+:%s+[-%.%d]+") ~= nil then
        resSplit(j)
      end
  end
  

  Note("Seek data on target: "..targetArray.shortn)
  --table.sort(targetArray.resists,tblLT)
  if qty>0 then
    tprint(getTableX(qty,dir))
  else
    tprint(targetArray)
  end
  
end

function tblLT(a,b)
  return a.resval<b.resval
end

function tblGT(a,b)
  return a.resval>b.resval
end

function getTableX(amount,direction)
  local outTable = {}
  if(direction == "top") then --sort largest -> smallest
    table.sort(targetArray.resists,tblGT)  
  else -- sort smallest -> largest. default for now, probably most common.
    table.sort(targetArray.resists,tblLT)
  end
  if amount<1 then amount=#targetArray.resists end
    for x=1,amount do
      if targetArray.resists[x].resval ~= 0 then
        table.insert(outTable,targetArray.resists[x])
      end
    end
  return outTable
end

 ----------------------- Plugin Update Code -----------------------
 -- Code taken from Durel's dinv plugin, originally via Crowley
 require("wait")
require("async")
json = require("json")

 plugin_url = "https://raw.githubusercontent.com/Anssett/Aard-Plugins/main/SeekRep.xml"
 SetVariable("DownloadURL", plugin_url)
 plugin_protocol = "HTTPS"
 plugin_prefix = "[SeekRep]"
 
 function update_check_alias()
     update_plugin("check")
     ColourNote("white", "", plugin_prefix .. " Checking for updated version...")
 end
 
 function update_install_alias()
     update_plugin("install")
     ColourNote("white", "", plugin_prefix .. " Checking for and installing updated version...")
 end
 
 function reload_plugin()
     local scriptPrefix = GetAlphaOption("script_prefix")
     local retval
 
     -- If the user has not already specified the script prefix for this version of mush, pick a
     -- reasonable default value
     if (scriptPrefix == "") then
         scriptPrefix = "\\\\\\"
         SetAlphaOption("script_prefix", scriptPrefix)
     end
 
     -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
     -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
     -- if it weren't installed? 
     retval = Execute(scriptPrefix.."DoAfterSpecial(0.1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
 end
 
 function update_plugin(mode)
     update_mode = mode
 
     wait.make(get_plugin_file)
 end
 
 function get_plugin_file()
     local urlThread = async.request(plugin_url, plugin_protocol)
 
     if not urlThread then
         note_error("Couldn't create async url request.")
         return
     end
 
     local timeout = 10
     local totTime = 0
     while (urlThread:alive() and totTime < timeout) do
         wait.time(0.1)
         totTime = totTime + 0.1
     end
 
     local remoteRet, pluginData, status, headers, fullStatus = urlThread:join()
 
     if not status then
         ColourNote("red", "", plugin_prefix .. " Couldn't download plugin file. No status code.")
         
         return
     end
 
     if (status ~= 200) then
         ColourNote("red", "", plugin_prefix .. " Plugin file request status code: " .. status .. ": " .. fullStatus)
         return
     end
     
     local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
     local currentVerStr  = string.format("%1.3f", currentVersion)
     local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
     local remoteVersion  = tonumber(remoteVerStr or "") or 0
 
     if remoteVersion == currentVersion then
         ColourNote("white", "", plugin_prefix .. " You are running the most recent version (v" .. currentVerStr .. ")")
     elseif (remoteVersion < currentVersion) then
         ColourNote("white", "", plugin_prefix .. " You have a newer version than is publicly available. (v" .. currentVerStr .. ")")
     elseif (update_mode == "check") then
         ColourNote("white", "", plugin_prefix .. " You are running v" .. currentVerStr .. ", but there's a newer version v" .. remoteVerStr)
     elseif (update_mode == "install") then
         ColourNote("white", "", plugin_prefix .. " Updating plugin from version " .. currentVerStr .. " to version " .. remoteVerStr) 
 
         local pluginFile = GetPluginInfo(GetPluginID(), 6)
         local file = io.open(pluginFile, "wb")
         file:write(pluginData)
         file:close()
         reload_plugin()
     else
         ColourNote("red", "", plugin_prefix .. " Invalid update mode: " .. update_mode)
     end
 end
 ----------------------- End Plugin Update Code -----------------------

]]>
</script> 

</muclient>
