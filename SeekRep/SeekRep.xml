<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, June 06, 2024, 8:25 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "SeekRep" generated by Plugin Wizard -->

<!--
comments go here
-->

<muclient>
<plugin
   name="SeekRep"
   author="Anssett"
   id="c9e9e568ec2b3bafe4dc76fa"
   language="Lua"
   purpose="To do things with Seek output."
   save_state="y"
   date_written="2024-06-06 20:24:22"
   requires="5.07"
   version="2.3"
   >
<description trim="y">
<![CDATA[
SeekRep
-------
Seek clanskill output reporter.

>> seekrep config help
   for initial setup configuration

>> seekrep help
   for general use
]]>
</description>

</plugin>

<triggers></triggers>

<aliases>
  <alias match="^seekrep\s(?<name>((\d*\.)?\w+))\s?(?<dir>(top|bot|all|immcheck|verbose))?\s?(?<qty>\d+)?" script="startSeek" regexp="y" enabled="y" group="seekrep" send_to="12" sequence="100" ></alias>
  <alias script="OnHelp" match="seekrep help" enabled="y"></alias>
  <alias match="seekrep update check" enabled="y" script="update_check_alias" sequence="99"/>
  <alias match="seekrep update install" enabled="y" script="update_install_alias" sequence="99"/>

  <alias match="^seekrep config(\s((?<command>(channel|rvcolor|rncolor|sepcolor|output)) (?<value>.+)))?$" enabled="y" regexp="y" script="config_handler" sequence="99"></alias>
  <alias match="^seekrep config(\s((?<command>(output)) (?<value>(echo|channel|both))))?$" enabled="y" regexp="y" script="config_handler" sequence="99"></alias>
  <alias match="^seekrep config (?<command>reset|help)$" enabled="y" regexp="y" script="config_handler" sequence="99"></alias>
</aliases>

<script>
<![CDATA[
require 'wrapped_captures'
require 'aardwolf_colors'
require 'tprint'

function seekFail()
  Note("something broke. Or seek failed and you need to try again.")
end

function initTarget()
targetArray = {
  shortn = "",
  baselev = 0,
  identical = 0,
  timeskilled = 0,
  align = "",
--  immunities = "",
  immunities={
    {immuName="Air", immuVal=false, immuType="magic" },
    {immuName="Acid", immuVal=false, immuType="magic" },
    {immuName="Bash", immuVal=false, immuType="physical" },
    {immuName="Cold", immuVal=false, immuType="magic" },
    {immuName="Disease", immuVal=false, immuType="magic" },
    {immuName="Earth", immuVal=false, immuType="magic" },
    {immuName="Electric", immuVal=false, immuType="magic" },
    {immuName="Energy", immuVal=false, immuType="magic" },
    {immuName="Fire", immuVal=false, immuType="magic" },
    {immuName="Holy", immuVal=false, immuType="magic" },
    {immuName="Light", immuVal=false, immuType="magic" },
    {immuName="Magic", immuVal=false, immuType="magic" },
    {immuName="Mental", immuVal=false, immuType="magic" },
    {immuName="Negative", immuVal=false, immuType="magic" },
    {immuName="Pierce", immuVal=false, immuType="physical" },
    {immuName="Poison", immuVal=false, immuType="magic" },
    {immuName="Shadow", immuVal=false, immuType="magic" },
    {immuName="Slash", immuVal=false, immuType="physical" },
    {immuName="Sonic", immuVal=false, immuType="magic" },
    {immuName="Water", immuVal=false, immuType="magic" }
  },
  notes = "",
  resists={
    {resName="Air", resval=0},
    {resName="Acid", resval=0},
    {resName="Bash", resval=0},
    {resName="Cold", resval=0},
    {resName="Disease", resval=0},
    {resName="Earth", resval=0},
    {resName="Electric", resval=0},
    {resName="Energy", resval=0},
    {resName="Fire", resval=0},
    {resName="Holy", resval=0},
    {resName="Light", resval=0},
    {resName="Magic", resval=0},
    {resName="Mental", resval=0},
    {resName="Negative", resval=0},
    {resName="Pierce", resval=0},
    {resName="Poison", resval=0},
    {resName="Shadow", resval=0},
    {resName="Slash", resval=0},
    {resName="Sonic", resval=0},
    {resName="Water", resval=0}
    }
}
end

function trim(s)
  return(string.gsub(s, "^%s*(.-)%s*$", "%1"))
end

function resSplit(instring)
  split1 = trim(string.sub(instring,0,31))
  split2 = trim(string.sub(instring,31,58))
  if(split1 ~= "") then
    local tbl = resSubSplit(split1)
    for i,j in ipairs(targetArray.resists) do
        if j.resName == tbl[1] then j.resval = tonumber(tbl[2]) end
    end
  end
  if (split2 ~= "") then
    local tbl=resSubSplit(split2)
    for i,j in ipairs(targetArray.resists) do
        if j.resName == tbl[1] then j.resval = tonumber(tbl[2]) end
    end
  end
end

function resSubSplit(instring)
  local splitTable = {}
  for str in string.gmatch(instring,"([^:]+)") do
    local tmpstr = string.gsub(str,"%%","")
    table.insert(splitTable,trim(tmpstr))
  end
  return splitTable
end

function parseImm(input)
  for _,j in pairs(input) do
    for x,y in ipairs(targetArray.immunities) do
      if string.lower(targetArray.immunities[x].immuName) == trim(string.lower(j)) then
        targetArray.immunities[x].immuVal = true
      elseif trim(string.lower(j)) == "allmagic" then
        if targetArray.immunities[x].immuType == "magic" then targetArray.immunities[x].immuVal = true end
      elseif trim(string.lower(j)) == "allphysical" then
        if targetArray.immunities[x].immuType == "physical" then targetArray.immunities[x].immuVal = true end
      end
    end
  end
end

function showVuln()
  local sepColor = getSepColor()
  local resNameColor = getResNameColor()
  local resValColor = getResValColor()

  local outString = resNameColor .. targetArray.shortn .. " NOT immune to: "
  local vulnArray = {}
  for i=1,#targetArray.immunities do
    if not targetArray.immunities[i].immuVal then
      table.insert(vulnArray,targetArray.immunities[i].immuName)
    end
  end
  catString = table.concat(vulnArray,", " )
  catSring = string.gsub(catString,", ",sepColor..", "..resValColor)
  outString = outString .. resValColor .. catString
  return outString
end

function OnHelp ()
  local borderColor = "@x025"
  local textColor = "@x178"
  local cmdColor = "@W"
  
  colorsToAnsiNote(borderColor .. "------------------" .. textColor .. " SeekRep Help " .. borderColor .. "------------------")
  Note()
  colorsToAnsiNote(borderColor .. "--==" .. textColor .. "Initial Setup" .. borderColor .. "==--")
  colorsToAnsiNote(textColor .. "After the first installation, run " .. cmdColor .. "seekrep config help")
  Note()
  colorsToAnsiNote(borderColor .. "--==" .. textColor .. " General Use " .. borderColor .. "==--")
  Note()
  colorsToAnsiNote(cmdColor .. "seekrep <target> [top|bot] [quantity]")
  colorsToAnsiNote(cmdColor .. "   <target>" .. textColor .. "    Required. Single keyword of target. Ordinal targets are ok (1.lasher, 2.lasher, etc.)")
  colorsToAnsiNote(textColor .. "               multiple words or quotes are not.")
  colorsToAnsiNote(cmdColor .. "   [top|bot|immcheck|all|verbose]" .. textColor .. "   Optional. If nothing given, defaults to " .. cmdColor .. "bot" .. textColor .. ". " .. cmdColor .. "bot" .. textColor .. " sorts ascending, " .. cmdColor .. "top" .. textColor .. " sorts descending.")
  colorsToAnsiNote(cmdColor .. "               immcheck" .. textColor .. " returns non-immune damtypes. " .. cmdColor .."all" .. textColor .. " does a rewrite of seek output to include 0 value resists instead of hiding them. ")
  colorsToAnsiNote(cmdColor .. "               verbose" .. textColor .. " is mostly used for debugging right now.")
  colorsToAnsiNote(cmdColor .. "   [quantity]" .. textColor .. "  Optional. Restricts quantity of results.")
  Note()
  colorsToAnsiNote(borderColor .. "--==" .. textColor .. "  Examples   " .. borderColor .. "==--")
  Note()
  colorsToAnsiNote(cmdColor .. "seekrep lasher top 3" .. textColor .. "  Performs " .. cmdColor .. "seek" .. textColor .. " on lasher, then prints his highest 3 resistances.")
  Note()
  colorsToAnsiNote(cmdColor .. "seekrep lasher 5" .. textColor .. "      Performs " .. cmdColor .. "seek" .. textColor .. " on lasher, then prints his lowest 5 resistances.")
  Note()
  colorsToAnsiNote(borderColor .. "--==" .. textColor .. "  Updating   " .. borderColor .. "==--")
  Note()
  colorsToAnsiNote(cmdColor .. "seekrep update check" .. textColor .. "   Checks if there's an update to the plugin.")
  colorsToAnsiNote(cmdColor .. "seekrep update install" .. textColor .. " Installs any available updates to this plugin.")
  colorsToAnsiNote(borderColor .. "--------------------------------------------------")
end

function startSeek(name,line, args)
  target = args.name
  dir = args.dir or "nil"
  qty = tonumber(args.qty) or -1
  initTarget()

  local command = "seek " .. target
  local startTag = "^\\-+$"
  local endTag = "^\\-+$"
  local tagsAreRegex=true
  local noCommandEcho=false
  local omitResponse=true
  local noFollowPrompt=false
  local sendViaExecute=true

  -- uncomment next 2 lines once wrapped_capture update from Crowley goes in. If it goes in.
--  local timeoutDuration=5
--  Capture.tagged_output(command,startTag,endTag,tagsAreRegex,noCommandEcho,omitResponse,noFollowPrompt,processCapture,sendViaExecute,seekFail,timeoutDuration)

  Capture.tagged_output(command,startTag,endTag,tagsAreRegex,noCommandEcho,omitResponse,noFollowPrompt,processCapture,sendViaExecute,seekFail)

end

function processCapture(lines)
  new_table = {}
  local outText = ""

  --remove color data etc
  for k, v in ipairs(lines) do
      stripped = strip_colours_from_styles(v)
      if (stripped ~= "" and 
          stripped ~="------------------------- [ Resistances ] ----------------------") then
          table.insert(new_table, stripped)
      end
  end

  --process de-colored data
  for i,j in ipairs(new_table) do
      if string.find(j,"Mob Short Name") ~=nil then
        targetArray.shortn = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Mob Base Level") ~= nil then
        targetArray.baselev = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Identical Mobs") ~= nil then
        targetArray.identical = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Times Killed") ~= nil then
        targetArray.timeskilled = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Alignment") ~= nil then
        targetArray.align = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"Note") ~= nil then
        targetArray.notes = trim(string.match(j, ":(.*)"))
      elseif string.find(j,"%a+%s+:%s+[-%.%d]+") ~= nil then
        resSplit(j)
      elseif string.find(j,"Immunities") ~= nil then
        parseImm(utils.split(trim(string.match(j, ":(.*)")),","))
      elseif string.find(j,"(%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s)(.*)") ~= nil then
        parseImm(utils.split(trim(j),","))
      end
  end

  if dir == "verbose" then
    tprint(targetArray)
  elseif dir=="immcheck" then
    outText = showVuln()
  elseif dir=="all" then
    redrawSeek()
  else
    if qty>0 then
      outText = tableString(getTableX(qty,dir))
    else
      --tprint(targetArray)
      --nobody's going to use this, right?
      --wrong.
      outText = tableString(getTableX(#targetArray.resists,"bot"))
    end
  end

if outText ~= "" then
    outType = getOutput()
    if (outType == "echo") or (outType == "both") then
      colorsToAnsiNote(outText)
    end
    if (outType == "channel") or (outType == "both") then
      SendNoEcho(getChannel() .. " "..outText)
    end
  end
end

function redrawSeek()
  colorsToAnsiNote("@W----------------------------------------------------------------@w")
  colorsToAnsiNote("@WYour research into @R" .. targetArray.shortn .. "@W reveals the following .... @w")
  Note() --"@W"
  colorsToAnsiNote("@GMob Short Name   : @w" .. targetArray.shortn .. "@w")
  colorsToAnsiNote("@GMob Base Level   : @w" .. targetArray.baselev .. "@w")
  colorsToAnsiNote("@GIdentical Mobs   : @w" .. targetArray.identical .. "@w")
  colorsToAnsiNote("@GTimes Killed     : @w" .. targetArray.timeskilled .. "@w")
  colorsToAnsiNote("@GAlignment        : @w" .. targetArray.align .. "@w")
  colorsToAnsiNote("@WNote             @w: @G" .. targetArray.notes .. "@w")
  colorsToAnsiNote("@WImmunities       : @w" .. "<do something here to reconstruct immunities>" .. "@w")
  colorsToAnsiNote("@W------------------------- @G[ Resistances ]@W ----------------------@w")
  colorsToAnsiNote("@gBash            @W:@g    " .. getVal("Bash") .. "%      Pierce          @W:@g    " .. getVal("Pierce") .. "% @w")
  colorsToAnsiNote("@gSlash           @W:@g    " .. getVal("Slash") .. "%      Acid            @W:@g    " .. getVal("Slash") .. "% @w")
  colorsToAnsiNote("@gAir             @W:@g    " .. getVal("Air") .. "%      Cold            @W:@g    " .. getVal("Cold") .. "% @w")
  colorsToAnsiNote("@gDisease         @W:@g    " .. getVal("Disease") .. "%      Earth           @W:@g    " .. getVal("Earth") .. "% @w")
  colorsToAnsiNote("@gElectric        @W:@g    " .. getVal("Electric") .. "%      Energy          @W:@g    " .. getVal("Energy") .. "% @w")
  colorsToAnsiNote("@gFire            @W:@g    " .. getVal("Fire") .. "%      Holy            @W:@g    " .. getVal("Holy") .. "% @w")
  colorsToAnsiNote("@gLight           @W:@g    " .. getVal("Light") .. "%%      Magic           @W:@g    " .. getVal("Magic") .. "% @w")
  colorsToAnsiNote("@gMental          @W:@g    " .. getVal("Mental") .. "%%      Negative        @W:@g    " .. getVal("Negative") .. "%% @w")
  colorsToAnsiNote("@gPoison          @W:@g    " .. getVal("Poison") .. "%%      Shadow          @W:@g    " .. getVal("Shadow") .. "% @w")
  colorsToAnsiNote("@gSonic           @W:@g    " .. getVal("Sonic") .. "%      Water           @W:@g    " .. getVal("Water") .. "% @w")
  colorsToAnsiNote("@W---------------------------------------------------------------- @w")


end

function getVal(searchStr)
  for i,j in pairs(targetArray.resists) do
    if string.lower(j.resName) == string.lower(searchStr) then
        return j.resval
    end
  end
--  tprint(targetArray.resists)
  return 0
end

function colorsToAnsiNote(data)
  return AnsiNote(ColoursToANSI(data))
end

function tblLT(a,b)
  return a.resval<b.resval
end

function tblGT(a,b)
  return b.resval<a.resval
end

function getTableX(amount,direction)
  local outTable = {}
  if(direction == "top") then --sort largest -> smallest
    table.sort(targetArray.resists,tblGT)
  else -- sort smallest -> largest. default for now, probably most common.
    table.sort(targetArray.resists,tblLT)
  end
  if amount<1 then amount=#targetArray.resists end
  if amount>#targetArray.resists then amount=#targetArray.resists end --lol ty scars
    for x=1,amount do
        table.insert(outTable,targetArray.resists[x])
    end
  return outTable
end

function tableString(intab)
  local buildString = ""
  local sepColor = getSepColor()
  local resNameColor = getResNameColor()
  local resValColor = getResValColor()
  local dupVals = false
--  local lastVal = -1

  buildString = resNameColor .. "Target: " .. resValColor .. targetArray.shortn .. sepColor .. " | "
  for x=1,#intab do
    if (x+1<=#intab) and (intab[x].resval == intab[x+1].resval) then
      --resval and resval+1 are equal, enter duplicate cluster loop
      if dupVals==false then --previous loop was not a duplicate loop, start duplicate loop
        dupVals = true
      end
      buildString = buildString .. resNameColor .. intab[x].resName
    elseif (dupVals ==true and x==#intab) then --last record, gotta check if dupvals flag is set
      buildString = buildString .. resNameColor .. intab[x].resName .. " " .. resValColor .. intab[x].resval .. "%" .. sepColor .. " | @w"
      dupVals = false
    else
      if dupVals == true then
        buildString = buildString ..intab[x].resName .. " " .. resValColor .. intab[x].resval .. "%".. sepColor .. " | @w"
        dupVals = false
      else
        buildString = buildString .. resNameColor.. intab[x].resName..": "..resValColor ..intab[x].resval .. "%" .. sepColor .. " | @w"
      end
    end

    if dupVals == true then 
      buildString = buildString .. ", "
    end
--[[ uncomment to restore to old functionality
    buildString = buildString .. resNameColor.. intab[x].resName..": "..resValColor ..intab[x].resval .. "%" .. sepColor .. " | @w"
    ]]
  end

  return buildString
end

function config_handler(name, line, args)
    arg = args.command
   if arg=="" then
    local sepColor = getSepColor()
    local resNameColor = getResNameColor()
    local resValColor = getResValColor()
     colorsToAnsiNote(resNameColor .. "--------------[" .. resValColor .. " SeekRep configuration "..resNameColor .. "]--------------")
     colorsToAnsiNote(resNameColor .. "")
     colorsToAnsiNote(resNameColor .. " Output config:       " .. resValColor .. getOutput())
     colorsToAnsiNote(resNameColor .. " Channel:             " .. resValColor .. getChannel())
     colorsToAnsiNote(resNameColor .. " Resist Value Color:  ")
                 Note("                      " .. getResValColor())
     colorsToAnsiNote(resNameColor .. " Resist Name Color:   ")
     Note("                      " .. getResNameColor())
     colorsToAnsiNote(resNameColor .. " Separator Color:     ")
     Note("                      " .. getSepColor())
     colorsToAnsiNote(resNameColor .. "")
     colorsToAnsiNote(resNameColor .. "----------------[" .. resValColor .. " End configuration "..resNameColor .. "]----------------")
   elseif arg == "channel" then
      Note("Set reporting channel to " .. args.value)
      setChannel(args.value)
   elseif arg == "rvcolor" then
      Note("Set resist value color to ".. args.value)
      setResValColor(args.value)
   elseif arg == "rncolor" then
      Note("Set resist name color to ".. args.value)
      setResNameColor(args.value)
   elseif arg == "sepcolor" then
      Note("Set separator color to " .. args.value)
      setSepColor(args.value)
   elseif arg == "output" then
      Note("Set output method to " .. args.value)
      setOutput(args.value)
   elseif arg == "help" then
      configHelp()
   elseif arg== "reset" then
     Note("Resetting config to defaults.")
     --reset things
     SaveState()
   end
 end

 function setOutput(value)
  SetVariable("output",value)
  SaveState()
 end
 
 function getOutput()
  local output = GetVariable("output")
  return output
 end

 function setChannel(value)
  SetVariable("outChannel",value)
  SaveState()
 end

 function getChannel()
  local chan = GetVariable("outChannel")
  return chan
 end
 
 function setResValColor(value)
  SetVariable("resValColor",value)
  SaveState()
 end

 function getResValColor()
  local rvColor = GetVariable("resValColor")
  return rvColor
 end

 function setResNameColor(value)
  SetVariable("resNameColor",value)
  SaveState()
 end
 
 function getResNameColor()
  local rnColor = GetVariable("resNameColor")
  return rnColor
 end
 
 function setSepColor(value)
  SetVariable("sepColor",value)
  SaveState()
 end
 
 function getSepColor()
  local sepColor = GetVariable("sepColor")
  return sepColor
 end

function configHelp()
  local sepColor = getSepColor()
  local resNameColor = getResNameColor()
  local resValColor = getResValColor()
  Note()
  colorsToAnsiNote(resNameColor .. "----------[" .. resValColor .. " SeekRep configuration options "..resNameColor .. "]----------")
  colorsToAnsiNote(resNameColor .. "")
  colorsToAnsiNote(resNameColor .. " seekrep config" .. resValColor .. " [output|channel|rvcolor|rncolor|sepcolor|reset|help] <value>")
  colorsToAnsiNote(resNameColor .. "   output:   "..resValColor.."[echo|channel|both] " ..resNameColor .. "set the output method - to echo, to a channel or to both echo and channel.")
  colorsToAnsiNote(resNameColor .. "   channel:  "..resValColor.."[string]            " ..resNameColor .. "set the game channel that seek reports to")
  colorsToAnsiNote(resNameColor .. "   rvcolor:  "..resValColor.."[string]            " ..resNameColor .. "set the color code for resist values. Use @ prefixed colors. Supports xterm or mud colors.")
  colorsToAnsiNote(resNameColor .. "   rncolor:  "..resValColor.."[string]            " ..resNameColor .. "set the color code for resist names. Use @ prefixed colors. Supports xterm or mud colors.")
  colorsToAnsiNote(resNameColor .. "   sepcolor: "..resValColor.."[string]            " ..resNameColor .. "set the color code for the separator characters. Supports xterm or mud colors.")
  colorsToAnsiNote(resNameColor .. "   reset:    "..resValColor.."                    " ..resNameColor .. "resets config values to defaults.")
  colorsToAnsiNote(resNameColor .. "   help:     "..resValColor.."                    " ..resNameColor .. "This data.")
  colorsToAnsiNote(resNameColor .. "")
  colorsToAnsiNote(resNameColor .. "---------------------[" .. resValColor .. " End help "..resNameColor .. "]---------------------")
end

function isEmpty(testme)
  return testme == nil or testme==""
end

function resetVars()
  setResValColor("@x184")
  setResNameColor("@W")
  setSepColor("@M")
  setChannel("gtell")
  setOutput("echo")
end

function initVars()
  if isEmpty(getResValColor()) then setResValColor("@x184") end
  if isEmpty(getResNameColor()) then setResNameColor("@W") end
  if isEmpty(getSepColor()) then setSepColor("@M") end
  if isEmpty(getChannel()) then setChannel("gtell") end
  if isEmpty(getOutput()) then setOutput("echo") end
end

function OnPluginInstall()
  OnHelp()
  initVars()
 end

 ----------------------- Plugin Update Code -----------------------
 -- Code taken from Durel's dinv plugin, originally via Crowley
 require("wait")
require("async")
json = require("json")

 plugin_url = "https://raw.githubusercontent.com/Anssett/Aard-Plugins/main/SeekRep/SeekRep.xml"
 SetVariable("DownloadURL", plugin_url)
 plugin_protocol = "HTTPS"
 plugin_prefix = "[SeekRep]"
 
 function update_check_alias()
     update_plugin("check")
     ColourNote("white", "", plugin_prefix .. " Checking for updated version...")
 end
 
 function update_install_alias()
     update_plugin("install")
     ColourNote("white", "", plugin_prefix .. " Checking for and installing updated version...")
 end
 
 function reload_plugin()
     local scriptPrefix = GetAlphaOption("script_prefix")
     local retval
 
     -- If the user has not already specified the script prefix for this version of mush, pick a
     -- reasonable default value
     if (scriptPrefix == "") then
         scriptPrefix = "\\\\\\"
         SetAlphaOption("script_prefix", scriptPrefix)
     end
 
     -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
     -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
     -- if it weren't installed? 
     retval = Execute(scriptPrefix.."DoAfterSpecial(0.1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
 end
 
 function update_plugin(mode)
     update_mode = mode
 
     wait.make(get_plugin_file)
 end
 
 function get_plugin_file()
     local urlThread = async.request(plugin_url, plugin_protocol)
 
     if not urlThread then
         note_error("Couldn't create async url request.")
         return
     end
 
     local timeout = 10
     local totTime = 0
     while (urlThread:alive() and totTime < timeout) do
         wait.time(0.1)
         totTime = totTime + 0.1
     end
 
     local remoteRet, pluginData, status, headers, fullStatus = urlThread:join()
 
     if not status then
         ColourNote("red", "", plugin_prefix .. " Couldn't download plugin file. No status code.")
         
         return
     end
 
     if (status ~= 200) then
         ColourNote("red", "", plugin_prefix .. " Plugin file request status code: " .. status .. ": " .. fullStatus)
         return
     end
     
     local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
     local currentVerStr  = string.format("%1.3f", currentVersion)
     local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
     local remoteVersion  = tonumber(remoteVerStr or "") or 0
 
     if remoteVersion == currentVersion then
         ColourNote("white", "", plugin_prefix .. " You are running the most recent version (v" .. currentVerStr .. ")")
     elseif (remoteVersion < currentVersion) then
         ColourNote("white", "", plugin_prefix .. " You have a newer version than is publicly available. (v" .. currentVerStr .. ")")
     elseif (update_mode == "check") then
         ColourNote("white", "", plugin_prefix .. " You are running v" .. currentVerStr .. ", but there's a newer version v" .. remoteVerStr)
     elseif (update_mode == "install") then
         ColourNote("white", "", plugin_prefix .. " Updating plugin from version " .. currentVerStr .. " to version " .. remoteVerStr) 
 
         local pluginFile = GetPluginInfo(GetPluginID(), 6)
         local file = io.open(pluginFile, "wb")
         file:write(pluginData)
         file:close()
         reload_plugin()
     else
         ColourNote("red", "", plugin_prefix .. " Invalid update mode: " .. update_mode)
     end
 end
 ----------------------- End Plugin Update Code -----------------------

]]>
</script> 

</muclient>
