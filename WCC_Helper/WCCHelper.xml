<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Saturday, January 27, 2024, 2:28 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "WCCHelper" generated by Plugin Wizard -->

<muclient>
<plugin
   name="WCCHelper"
   author="Anssett"
   id="ec8f728f2950364a36811c5e"
   language="Lua"
   purpose="To Git Gud"
   save_state="y"
   date_written="2024-01-27 14:24:24"
   requires="5.07"
   version="1.1"
   >
<description trim="y">
<![CDATA[

]]>
</description>

</plugin>


<!--  Triggers  -->

<triggers>
  <trigger name="wcc_dead_whelp" enabled="n" group="WCC" keep_evaluating="y" match="^hands, the floating ice crystals strangely warm to the touch\.$" regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_fried_egg" enabled="n" group="WCC" keep_evaluating="y" match="^solidifies into crystalline ice shards all across its body\." regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_run_start" enabled="y" group="WCC_start" keep_evaluating="y" match="^with an overwhelming urge to fall to your knees and hurl\.$" regexp="y" script="notify" sequence="100"></trigger>
  <!-- excessive data, hiding, do not re-enable dangit <trigger name="wcc_stalactite_fell" enabled="y" group="WCC" keep_evaluating="y" match="^You see a massive stalactite fall from the cave ceiling and land in$" regexp="y" script="notify" sequence="100"></trigger> -->
  <trigger name="wcc_stalactite_side" enabled="n" group="WCC" keep_evaluating="y" match="^the (?<stalactite_direction>(north|south|east|west))ern side of the cavern\.$" regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_fissure_spawned" enabled="n" group="WCC" keep_evaluating="y" match="^enter it and escape this prison!$" regexp="y" send_to="12" script="notify" sequence="100"></trigger>
  <trigger name="wcc_shards_placed" enabled="n" group="WCC" keep_evaluating="y" match="^begin to float into the air and whirl about at unbelievable speeds\.$" regexp="y" send_to="12" script="notify" sequence="100"></trigger>
  <trigger name="wcc_run_stop" enabled="n" group="WCC" keep_evaluating="y" match="^You hear a faint whisper in the back of your mind, warning you not to return for (?<remain_hour>\d{1,2})\:(?<remain_min>\d{1,2})\:(?<remain_sec>\d{1,2})\.$" regexp="y" script="notify" send_to="12" sequence="100"></trigger>
  <trigger name="wcc_shards_flee" enabled="n" group="WCC" keep_evaluating="y" match="^Uh oh, looks like you've drawn the attention of (?:Anxia, the Frigid One|Someone)!$" regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_stalac_yoink" enabled="n" group="WCC" keep_evaluating="y" match="^A powerful surge of frigid energy rips through the room, pulling you$" regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_found_fissure" enabled="n" group="WCC" keep_evaluating="y" match="^A large fissure has torn the cave wall wide open here\.$" regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_stalactite_warn" enabled="n" group="WCC" keep_evaluating="y" match="^stalactites above you wobble threateningly\.$" regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_stalactite_dead" enabled="n" group="WCC" keep_evaluating="y" match="^You get (?:[\d,]+) gold coin(?:s)? from .* corpse of a fallen stalactite\.$" regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_wyrm_room" enabled="n" group="WCC" keep_evaluating="y" match="^A slight tremor in the ground is never a good sign! Run!$" regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_wyrm_move" enabled="n" group="WCC" keep_evaluating="y" match="^A burrowing ice wyrm rockets past you, cleaving through the ground like a shark\.$" regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_breath_melt" enabled="n" group="WCC" keep_evaluating="y" match="^The thin cloud of ice shards disperses into the air, as if it never even existed\.$" regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_breath_boom" enabled="n" group="WCC" keep_evaluating="y" match="^you has disappeared, like the last vestiges of mist in the morning\.$" regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_breath_damaged" enabled="n" group="WCC" keep_evaluating="y" match="^whirling vortex of ice shards\. \[\-1 Durability\]$" regexp="y" script="notify" sequence="100"></trigger>
  <trigger name="wcc_find" regexp="y" group="WCC_path" match="^(\(.*\))*\s+Blending in perfectly with the snow is a wandering yeti\.$" enabled="y" sequence="100" script="setEntrance"></trigger>
  <trigger name="wcc_u_ded" regexp="y" match="^You die\.$" enabled="n" sequence="100" script="notify"></trigger>
  <trigger name="wcc_path_done" regexp="y" group="WCC_path" match="^\{WCCPATHDONE\}$" enabled="y" sequence="100" omit_from_output="y"></trigger>
  <trigger name="wcc_path_start" regexp="y" group="WCC_path" match="^\{WCCPATHSTART\}$" enabled="y" sequence="100" omit_from_output="y"></trigger>
  <trigger name="wcc_yeti_poof" regexp="y" group="WCC_path" match="^You blink and a wandering yeti is suddenly gone, blending in perfectly with the snow\." enabled="y" sequence="100" script="resetEntrance"></trigger>
  <trigger name="breath_worth" regexp="y" group="wcc_breath" match="^\| Worth\s+:\s+(?<worth>\d+)\s+Weight :\s+\d+\s+\|$" enabled="n" sequence="100" script="set_breath" omit_from_output="n"></trigger>
  <trigger name="breath_time" regexp="y" group="wcc_breath" match="^\| Notes\s+: Expires in (?<hour>\d{2}):(?<minute>\d{2}):(?<second>\d{2}) of game time\s+\|$" enabled="n" sequence="100" script="set_breath" omit_from_output="n"></trigger>
  <trigger name="breath_id_enable" regexp="y" group="WCC" match="^\| Keywords   : last breath\s+\|$" enabled="y" sequence="99" script="enableBreathID" omit_from_output="n"></trigger>
  <trigger name="breath_id_disable" regexp="y" group="wcc_breath" match="^\+\-+\+$" enabled="n" sequence="100" script="disableBreathID" omit_from_output="n"></trigger>
</triggers>

<!--  Plugin help  -->

<aliases>
  <alias script="OnHelp" match="wcc help" enabled="y"></alias>
  <alias script="report" match="wcc report" enabled="y"></alias>
  <alias script="timeReport" match="wcc time" enabled="y"></alias>
  <alias script="findWCC" match="wcc find" enabled="y"></alias>
  <alias script="statusToggle" match="wcc status" enabled="y"></alias>

  <alias match="wcc update check" enabled="y" script="update_check_alias" sequence="99"/>
  <alias match="wcc update install" enabled="y" script="update_install_alias" sequence="99"/>
</aliases>

<timers>
  <timer minute="0" second="6" enabled="n" script="sendStatus" name="wcc_status_timer" group="wcc_timers"></timer>
  <timer minute="0" second="3" enabled="n" name="wcc_map_timer" send_to="10">map</timer>
</timers>


<script>
<![CDATA[
require 'aardwolf_colors'
require 'gmcphelper'

local foreColor = "red"
local backColor = "blue"
local timerStart = 0
local lastRun = 0
local fastestRun = 0
local nextRunTime = 0
local wccTag = "@M(@YWCC@M)@w"
local entrance = -1

local startShard = 48
local minShard = 54
local shardOffset = 7

local minStal = 81
local stalOffset = 7
local minWyrm = 15

function OnPluginInstall()
  initVars()
end

function initVars()
  wcc_data = {
    ["egg_dead"] = 0,
    ["whelp_dead"] = 0,
    ["stalac_dead"] = 0,
    ["breath_durability"] = 0,
    ["breath_timer"] = 0,
    ["next_shard"] = 0,
    ["last_shard"] = 0,
    ["next_stalac"] = 0,
    ["last_stalac"] = 0,
    ["next_wyrm"] = 0,
    ["last_wyrm"] = 0,
  }
end

function statusToggle()
  local isEnabled = GetTimerInfo("wcc_status_timer",6)
  --isEnabled = not isEnabled
  SetTimerOption("wcc_status_timer","enabled",not isEnabled)
  if not isEnabled then
    ResetTimer("wcc_status_timer")
  end
end

function statusSwitch(statusOn)
  SetTimerOption("wcc_status_timer","enabled",statusOn)
end

function sendStatus()
  if wcc_data["next_stalac"] == 0 then
    nextStal = "@RKill more whelps.@w"
  else
    stalTime = os.difftime(wcc_data["next_stalac"],os.time())
    nextStal = tostring(stalTime) .. " to " .. tostring(stalTime + stalOffset) .. " sec"
  end

  shardTime = os.difftime(wcc_data["next_shard"],os.time())
  nextShards = tostring(shardTime) .. " to " .. tostring(shardTime + shardOffset) .. " sec"
  
  if wcc_data["breath_timer"] == 0 then
    breathString = "@RKill a whelp."
  else
    breathString = "@Y" .. tostring(os.difftime(wcc_data["breath_timer"],os.time())).." @Wsec"
  end

  Note()
  --colorsToAnsiNote("@M(@YWCC@M)@W [Stalactite in @Y" .. nextStal .. "@W]")
  colorsToAnsiNote(wccTag .. " @WShards in @Y".. nextShards .. "@W Stalactite in @Y" .. nextStal .. "@w")
  colorsToAnsiNote(wccTag .. " @WBreath: " .. breathString .. " @B|@Y" .. wcc_data["breath_durability"] .. "@W charges @B|@W Egg @Y"..wcc_data["egg_dead"].."@B/@y8@W @B|@W Whelp @Y"..wcc_data["whelp_dead"].."@B/@y8@W @B|@W Stalac @Y"..wcc_data["stalac_dead"].."@W [@y" ..  os.date("%M:%S",os.time()-timerStart) .. "@W]@w")
  Note()
end

--in case we want to do more than just colorHighlight. more processor cycles ftw.
function notify(name,line,wildcards)
  Note()
  if name=="wcc_run_start" then
    startRun()
  elseif name=="wcc_dead_whelp" then
    deadWhelp()
  elseif name=="wcc_fried_egg" then
    deadEgg()
  elseif name=="wcc_shards_flee" then
    shardWarning()
  elseif name=="wcc_shards_placed" then
    colorsToAnsiNote(wccTag .. " @WShards placed. @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
  elseif name=="wcc_stalactite_warn" then
    stalacWarning()
  elseif name=="wcc_stalac_yoink" then
    colorsToAnsiNote(wccTag .. "@WStalactite moved you. Check your location. @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
    
    --[[ this is commented out for good reason. it's not needed. don't uncomment, future ans. you don't want this part.
          only reason it's commented and not deleted is because yOU ALREADY RECREATED IT ONCE. STOP IT. you are
          literally doing the thing you want in the next option. knock it the hell off.
          you just considered uncommenting this despite the warning, so now it's longer.

  elseif name=="wcc_stalactite_fell" then
    --notify stalactite landed
    colorsToAnsiNote(wccTag .. " @WStalactite landed. @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
    ]]--

  elseif name=="wcc_stalactite_side" then
    --get side of area stalac landed in. dont know if that's needed yet.
    outString="Stalactite landed on " .. wildcards.stalactite_direction .. " side."
    colorsToAnsiNote(wccTag .. " @W"..outString.. " @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
  elseif name=="wcc_stalactite_dead" then
    deadStalac()
  elseif name=="wcc_fissure_spawned" then
    --notify to go look for fissure
    --may do other things in the future?
    colorsToAnsiNote(wccTag .. " @WFissure spawned, locate it. @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
  elseif name=="wcc_found_fissure" then
    --notify to enter fissure
    colorsToAnsiNote(wccTag .. " @WFissure here! @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
    --set the room for a later walkto? dangerous if wyrm is up maybe don't do that.
  elseif name=="wcc_wyrm_room" then
    wyrmSpawnInRoom()    
  elseif name=="wcc_wyrm_move" then
    SendNoEcho("map")
    colorsToAnsiNote(wccTag .. " @WWyrm moved, check map. @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
  elseif name=="wcc_breath_melt" then
    --SendNoEcho("wear breath")
    breathMelt()
  elseif name=="wcc_breath_boom" then
    SendNoEcho("wear breath")
    breathID()
  elseif name=="wcc_breath_damaged" then
    wcc_data["breath_durability"] = wcc_data["breath_durability"] - 1
  elseif name=="wcc_run_stop" then
    endRun(false,wildcards.remain_hour,wildcards.remain_min,wildcards.remain_sec)
  elseif name == "wcc_u_ded" then
    endRun(true,0,0,0)
  end
  Note()
end

function startRun()
  --init vars
  initVars()

  --start run timer, enable triggers
  timerStart = os.time()
  EnableTriggerGroup("WCC", true)
  EnableTrigger("wcc_u_ded", true)

  wcc_data["next_shard"] = os.time() + startShard
  --notify run start
  colorsToAnsiNote(wccTag .. " @WStarted at	@w[@y" .. os.date("%x %X",timerStart) .. "@w]")
  statusSwitch(true)
end

function deadWhelp()
  colorsToAnsiNote(wccTag .. " @WWhelp dead, wear breath. @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
  if (wcc_data["whelp_dead"] == 0) then
    wcc_data["next_stalac"] = os.time() + minStal
    Execute("wear breath")
    breathID()
  end
  if(wcc_data["whelp_dead"] == 3) then
    wcc_data["next_wyrm"] = os.time() + minWyrm
    EnableTrigger("wcc_map_timer", true)
  end
  wcc_data["whelp_dead"] = wcc_data["whelp_dead"] + 1
end

function deadEgg()
  colorsToAnsiNote(wccTag .. " @WDead egg. @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
  wcc_data["egg_dead"] = wcc_data["egg_dead"]+1
end

function deadStalac()
  wcc_data["stalac_dead"] = wcc_data["stalac_dead"] + 1
end

function shardWarning()
  colorsToAnsiNote(wccTag .. " @WFLEE and place shards @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
  wcc_data["last_shard"] = wcc_data["next_shard"]
  wcc_data["next_shard"] = os.time() + minShard
end

function stalacWarning()
  colorsToAnsiNote(wccTag .. " @WStalactite soon. @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
  wcc_data["last_stalac"] = wcc_data["next_stalac"]
  wcc_data["next_stalac"] = os.time() + minStal
end

function wyrmSpawnInRoom()
  SendNoEcho("map")
  colorsToAnsiNote(wccTag .. " @WWyrm is in your room, MOVE NOW. @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
  wcc_data["last_wyrm"] = wcc_data["next_wyrm"]
  wcc_data["next_wyrm"] = os.time() + minWyrm
end


function endRun(dead, rm_hour, rm_min, rm_sec)
  lastRun = os.time()
  if (not dead) then
--[[ don't think this bit is necessary now ... we'll see
    remainHour = wildcards.remain_hour
    remainMin = wildcards.remain_min
    remainSec = wildcards.remain_sec
    ]]

    nextRunSec = (rm_hour * 3600) + (rm_min * 60 ) + rm_sec

    nextRunTime = lastRun + nextRunSec
    runString = wccTag .. " @WCome back at @y" .. os.date("%x %X",nextRunTime) .. "@W.@w"
    colorsToAnsiNote(runString)
  end
  --stop run timers
  runTimer = os.difftime(lastRun,timerStart)
  runMins = math.floor(runTimer/ 60)
  runSecs = runTimer-(runMins*60)
  statusSwitch(false)
  EnableTrigger("wcc_map_timer", false)

  --report run stats
  outString = wccTag .. " @WRun took @y" .. runMins .. " @Wminutes and @y" .. runSecs .. " @Wseconds, starting at @y" .. os.date("%x %X",timerStart) .. " @Wand ending at @y" .. os.date("%x %X",lastRun) .. "@w"
  colorsToAnsiNote(outString)
  EnableTriggerGroup("WCC",false)
  EnableTrigger("wcc_u_ded", false)
  EnableTimerGroup("wcc_timers",false)
end

function set_breath(name, line, args)
  if name=="breath_worth" then
    wcc_data["breath_durability"] = args.worth
--    Note(wcc_data["breath_durability"])
  elseif name=="breath_time" then
    local breathtime = (tonumber(args.hour) * 60 * 60) + (tonumber(args.minute) * 60) + tonumber(args.second)
    wcc_data["breath_timer"] = os.time() + breathtime
--    Note(wcc_data["breath_timer"])
  end
  --Note("durability: " .. wcc_data["breath_durability"] .. " timer: " .. wcc_data["breath_timer"])
end

function breathID()
  --enable id trigger group
  enableBreathID()
  --id worn breath
  Execute("id breath worn")
end

function enableBreathID()
  EnableTriggerGroup("wcc_breath",true)
end

function disableBreathID()
  EnableTriggerGroup("wcc_breath",false)
end

function breathMelt()
  colorsToAnsiNote(wccTag .. " @WBreath melted. @w[@y" .. os.date("%M:%S",(os.time()-timerStart)) .. "@w]")
  if os.difftime(tonumber(wcc_data["breath_timer"]),os.time())<= 0 then
    Execute("wear breath")
    breathID()
  end
end

function findWCC()
  Note(tostring(entrance))
  if entrance==-1 then
    Execute("mapper goto 18347")
    local searchPath = "s;s;s;e;n;n;n;e;s;s;s;e;n;n;n;e;s;s;s;e;n;n;e;s;s;e;n;n;e;s;s;e;n;n;n;e;s;s;e;n;n"
    SendNoEcho("echo {WCCPATHSTART}")
    for i in string.gmatch(searchPath, "[^;]+") do SendNoEcho(i) end
    SendNoEcho("echo {WCCPATHDONE}")
  else
    EnableTrigger("wcc_find",false)
    Execute("mapper goto " .. entrance)
    resetEntrance()
    
  end
end

--[[ debug function, dont need i think...
function reportWCCPath()
  Note(tostring(entrance))
end
]]--

function setEntrance()
  EnableTrigger("wcc_find",false)
  entrance = tonumber(gmcp("room.info.num"))
end

function resetEntrance()
  EnableTrigger("wcc_find",true)
  entrance=-1
end

function report()
  colorsToAnsiNote(wccTag .. " @WYou can run again at @w[@y" .. os.date("%x %X",nextRunTime) .. "@w]")
  colorHighlight("You can run again at ".. os.date("%x %X",nextRunTime), foreColor, backColor)
end

function timeReport()
end

--i might not need this, but i also might.
function colorsToAnsiNote(data)
  return AnsiNote(ColoursToANSI(data))
end

--my brain parses this command better in this order. sue me.
function colorHighlight(inText, textColor, bgColor)
    ColourNote (textColor, bgColor, inText)
end


function OnHelp ()
  Note()
  ColourNote("white","black","            >>>","#05b7f2","black"," WCC HELPER ","white","black","<<<")
  Note()
  ColourNote("#a8acad","black","Collection of triggers and a couple of aliases to send notifications in White Claw Caverns")
  ColourNote("#a8acad","black","Mostly self-running. Expected behavior is mostly notifications.")
  ColourNote("#a8acad","black","Sends map regularly on some events (wyrm-related), wears breath semi-intelligently.")
  Note()
  ColourNote("white","black","Commands:")
  ColourNote("#a8acad","black","wcc help","white","black"," - this")
  ColourNote("#a8acad","black","wcc find","white","black"," - Looks for the yeti. Once yeti is found, sending wcc find again will run you to the yeti's room. You still have to give flaming.")
  ColourNote("#a8acad","black","wcc report <channel>","white","black"," - report stats to <channel>. Might not work, it's been a while. Probably doesn't work")
  Note()
  ColourNote("white","black","Updating:")
  ColourNote("#a8acad","black","wcc update check","white","black"," - this")
  ColourNote("#a8acad","black","wcc update install","white","black"," - Looks for the yeti. Once yeti is found, sending wcc find again will run you to the yeti's room. You still have to give flaming.")
  Note()
  ColourNote("#a8acad","black","any other aliases in this plugin","white","black"," - Used for testing. ")

end

 ----------------------- Plugin Update Code -----------------------
 -- Code taken from Durel's dinv plugin, originally via Crowley
require("wait")
require("async")
json = require("json")

 plugin_url = "https://raw.githubusercontent.com/Anssett/Aard-Plugins/refs/heads/main/WCC_Helper/WCCHelper.xml"
 SetVariable("DownloadURL", plugin_url)
 plugin_protocol = "HTTPS"
 plugin_prefix = "[WCCHelper]"
 
 function update_check_alias()
     update_plugin("check")
     ColourNote("white", "", plugin_prefix .. " Checking for updated version...")
 end
 
 function update_install_alias()
     update_plugin("install")
     ColourNote("white", "", plugin_prefix .. " Checking for and installing updated version...")
 end
 
 function reload_plugin()
     local scriptPrefix = GetAlphaOption("script_prefix")
     local retval
 
     -- If the user has not already specified the script prefix for this version of mush, pick a
     -- reasonable default value
     if (scriptPrefix == "") then
         scriptPrefix = "\\\\\\"
         SetAlphaOption("script_prefix", scriptPrefix)
     end
 
     -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
     -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
     -- if it weren't installed? 
     retval = Execute(scriptPrefix.."DoAfterSpecial(0.1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
 end
 
 function update_plugin(mode)
     update_mode = mode
 
     wait.make(get_plugin_file)
 end
 
 function get_plugin_file()
     local urlThread = async.request(plugin_url, plugin_protocol)
 
     if not urlThread then
         note_error("Couldn't create async url request.")
         return
     end
 
     local timeout = 10
     local totTime = 0
     while (urlThread:alive() and totTime < timeout) do
         wait.time(0.1)
         totTime = totTime + 0.1
     end
 
     local remoteRet, pluginData, status, headers, fullStatus = urlThread:join()
 
     if not status then
         ColourNote("red", "", plugin_prefix .. " Couldn't download plugin file. No status code.")
         
         return
     end
 
     if (status ~= 200) then
         ColourNote("red", "", plugin_prefix .. " Plugin file request status code: " .. status .. ": " .. fullStatus)
         return
     end
     
     local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
     local currentVerStr  = string.format("%1.3f", currentVersion)
     local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
     local remoteVersion  = tonumber(remoteVerStr or "") or 0
 
     if remoteVersion == currentVersion then
         ColourNote("white", "", plugin_prefix .. " You are running the most recent version (v" .. currentVerStr .. ")")
     elseif (remoteVersion < currentVersion) then
         ColourNote("white", "", plugin_prefix .. " You have a newer version than is publicly available. (v" .. currentVerStr .. ")")
     elseif (update_mode == "check") then
         ColourNote("white", "", plugin_prefix .. " You are running v" .. currentVerStr .. ", but there's a newer version v" .. remoteVerStr)
     elseif (update_mode == "install") then
         ColourNote("white", "", plugin_prefix .. " Updating plugin from version " .. currentVerStr .. " to version " .. remoteVerStr) 
 
         local pluginFile = GetPluginInfo(GetPluginID(), 6)
         local file = io.open(pluginFile, "wb")
         file:write(pluginData)
         file:close()
         reload_plugin()
     else
         ColourNote("red", "", plugin_prefix .. " Invalid update mode: " .. update_mode)
     end
 end
 ----------------------- End Plugin Update Code -----------------------

]]>
</script> 

</muclient>
